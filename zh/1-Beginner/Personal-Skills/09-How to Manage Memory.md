# 如何管理記憶體
[//]: # (Version:1.0.0)
記憶體是一種你不可以耗盡的珍貴資源。在一段時期裡，你可以無視它，但最終你必須決定如何管理記憶體。

堆記憶體是在單一子程式範圍外，需要持續（保留）的空間。一大塊記憶體，在沒有東西指向它的時候，是無用的，因此被稱為*垃圾*。根據你所使用的系統的不同，你可能需要自己顯式釋放將要變成垃圾的記憶體。更多時候你可能使用一個有*垃圾回收器*的系統。一個垃圾回收器會自己注意到垃圾的存在並且在不需要程式設計師做任何事情的情況下釋放它的記憶體空間。垃圾回收器是奇妙的：它減小了錯誤，然後增加了程式碼的簡潔性。如果可以的話，使用垃圾回收器。

但是即使有了垃圾回收機制，你還是可能把所有的記憶體填滿垃圾。一個典型的錯誤是把雜湊表作為一個快取，但是忘了刪除對雜湊表的引用。因為引用仍然存在，被引用者是不可回收但卻無用的。這就叫做*記憶體洩露*。你應該儘早發現並且修復記憶體洩露。如果你有一個長時間執行的系統，記憶體可能在測試中不會被耗盡，但可能在使用者那裡被耗盡。

建立新物件在任何系統裡都是有點昂貴的。然而，在子程式裡直接為局部變數分配記憶體通常很便宜，因為釋放它的策略很簡單。你應該避免不必要的物件建立。

當你可以定義你一次需要的數量的上界的時候，一個重要的情況出現了：如果這些物件都佔用相同大小的記憶體，你可以使用單獨的一塊記憶體，或快取，來持有所有的這些物件。你需要的物件可以在這個快取裡以迴圈的方式分配和釋放，所以它有時候被稱為環快取。這通常比堆記憶體分配更快。（譯者注：這也被稱為物件池。）

有時候你需要顯式釋放已分配的記憶體，所以它可以被重新分配而非依賴於垃圾回收機制。然後你必須謹慎機智地分配每一塊記憶體，並且為它設計一種在合適的時候重新分配的方式。這種銷燬的方式可能隨著你建立的物件的不同而不同。你必須保證每個記憶體分配操作都與一個記憶體釋放操作相匹配。（譯者注：在C裡面，no malloc no free，在C++裡面，no new no delete）。這通常是很困難的，所以程式設計師通常會實現一種簡單的方式或者垃圾回收機制，比如引用計數，來為它們做這件事情。

Next [如何處理偶現的 Bug](10-How to Deal with Intermittent Bugs.md)
